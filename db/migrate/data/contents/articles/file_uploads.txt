<p>In this tutorial, I'll create a simple application to upload photos through a simple HTML form, and store them in the database, then render and display them on demand. The steps we'll go through are as follows:</p>

<ul>
<li><b>Create a model.</b> We'll use this model for the photographs, and we'll call it "Photo"</li>
<li><b>Create a migration.</b> Use a database migration to create a table in the database to hold the photographs</li>
<li><b>Handle the upload.</b> In the view, we'll create a template containing a HTML multi-part form and a corresponding action that will allow users to upload their photograph files</li>
<li><b>Render the image from the database.</b> Once you've got the images in the database, how do you pull them out and display them again? That's what I'll show you...</li></ul>

<minihead>Building the foundations</minihead>
<p>
First things first: let's create the photograph model from the command line: </p>
<p>
<c>ruby script/generate model photo</c></p>
<p>
The next step is in the controller. Let's create a `photo_admin` controller to take care of uploading, editing and deleting photos:
</p>
<p><c>    ruby script/generate controller photo_admin </c></p>
<p>
We'll also use Rails' scaffolding generator to create some basic actions and views that we can edit and work with: </p>
<p><c>
    ruby script/generate scaffold photo photo_admin </c></p>

<p>You might be asked by the generator script if it's okay to overwrite some of the existing controller files. Seeing as we haven't edited them even once, you can safely answer yes. </p>

<p>Using migrations, we'll create a simple table containing fields to hold a description of the image, along with a binary field that will hold the binary image data itself. Open the <c>001_create_photos.rb</c> migration in the <c>db/migrate</c> directory, and edit it as follows: </p>

<r>class CreatePhotos &lt; ActiveRecord::Migration 
    def self.up create_table :photos do |t| 
        t.column :description, :string 
        t.column :content_type, :string 
        t.column :filename, :string 
        t.column :binary_data, :binary 
    end 
end</r>
<p>
We can then run the migration from the command line:</p>
<p><c>
    rake db:migrate</c></p>
<p>You might be asked by the generator script if it's okay to overwrite some of the existing controller files. Seeing as we haven't edited them even once, you can safely answer yes. </p>
<p>
Using migrations, we'll create a simple table containing fields to hold a description of the image, along with a binary field that will hold the binary image data itself. Open the <c>001_create_photos.rb</c> migration in the <c>db/migrate</c> directory, and edit it as follows: </p>
<r>class CreatePhotos &lt; ActiveRecord::Migration 
    def self.up create_table :photos do |t| 
        t.column :description, :string 
        t.column :content_type, :string 
        t.column :filename, :string 
        t.column :binary_data, :binary 
    end 
end</r>
<p>
We can then run the migration from the command line:
</p><p><c>
    rake db:migrate</c></p>

<p>If all has gone well, you should now have a table named photos in your database with all the fields you need to hold your image data! The next step is in the controller. Let's create a <c>photo_admin</c> controller to take care of uploading, editing and deleting photos:<p>
<p><c>    
    ruby script/generate controller photo_admin</c></p>

<p>We'll also use Rails' scaffolding generator to create some basic actions and views that we can edit and work with:</p>

<p><c>    ruby script/generate scaffold photo photo_admin </c></p>

<p>You might be asked by the generator script if it's okay to overwrite some of the existing controller files. Seeing as we haven't edited them even once, you can safely answer yes. </p>

<subhead>Creating a new photo</subhead>

<p>Excellent! Now we have the foundations laid, it's time to handle uploading a new photograph to the database. As it happens, Rails' scaffolding generator has already created the new and create actions in the <c>photo_admin</c> controller we just generated, so we don't even need to touch it yet! Instead we'll concentrate on the view for the new action. </p>
<p>
To start with, we need to create a multipart form in the <c>new.rhtml</c> view template. This allows the browser to send image files (or any other kind of files) to the server. Let's change the existing <c>form_tag</c> helper to a <c>form_for</c> helper that will wrap our <c>photo</c> model object: </p>

<rh>&lt;% form_for(:photo, @photo, :url=&gt;{:action=>'create'}, :html=&gt;{:multipart=>true}) do |form| %&gt;</rh>

<p>Notice the <c>:multipart =&gt; true</c> option at the end of the tag. It's always good to use the brackets and braces for clarity when using <c>form_for</c> with a multipart option. So many errors will happen if the form isn't rendered correctly using <c>:multipart =&gt; true</c>, so it's a time saver to always make sure you get that bit right from the beginning!</p>

<p>Next, let's remove the scaffolded entry for <c>&lt;%= render :partial =&gt; 'form' %&gt;</c> and instead add two form fields: one to handle the uploading of the photo, and the other to type in a description of the photo. </p>
<rh>&lt;%= form.file_field :image_file %&gt; 
&lt;%= form.text_field :description %&gt;</rh>

<p>To create a field in the form which allows users to browse for and upload their files, we use Rails' specific <c>file_field</c> helper. It takes the same options as the <c>text_field</c>, the object assigned to the template (in this case, form) and the method for accessing a specific attribute (in this case <c>image_file</c>) Have you spotted the first anomaly yet? No? Well let's see: we've used <c>:description</c> in the <c>text_field</c> to enter our photo's description, and that's great, because we have a corresponding description field in our database table. But we've used <c>image_file</c> to upload our image data, and there's no corresponding <c>image_file</c> field in our <c>photos</c> table. So what's going on? </p>
<p>
It turns out that when uploading a file, you don't get receive just one string, such as the binary image data, but a more complex object containing not just the file's binary data but its filename and content-type (such as <c>image/jpg</c> or <c>image/gif</c>). These are all stored together in <c>:image_file</c>, so what we'll need to do is extract the data and assign it the correct model attributes. The best place to do that is in the <c>photo</c> model, in <c>app/models/photo.rb</c>
</p><r>class Photo &lt; ActiveRecord::Base 
    def image_file=(input_data) 
        self.filename = input_data.original_filename 
        self.content_type = input_data.content_type.chomp 
        self.binary_data = input_data.read 
    end 
end</r>
<p>Here, we take the contents of <c>image_file</c> and we use three methods to extract the data and assign it to the model attributes that match our database table: the methods are <c>original_filename</c>, <c>content_type</c> and <c>read</c>.</p> 
<ul>
<li><c>original_filename</c> gives you surprisingly enough the original filename of the file</li>
<li><c>content_type</c> provides you with the content-type of the data, such as whether it is an <c>image/gif</c> or an <c>audio/wav</c> which is useful for validation </li>
<li><c>read</c> lets you actually get at the binary data </li>
</ul>
<p>

The <c>chomp</c> method at the end of <c>content_type</c> simply removes any extraneous newline characters, to make it neater. </p>
<p>
Now, if you go to <c>yourapp/photo_admin/new</c> you should be able to upload a file. Try a small one at first (under 10k would be good) You'll know if it works because you'll be returned to the <c>/photo_admin/list</c> action, and you'll see the details of your file, along with a lot of gibberish under the binary column. That's because Rails is rendering your binary image data as text. Instead, we want a way to get the binary image data back out of the database and display it as an actual image... </p>

<subhead>Rendering an image stored in the database</subhead>
<p>
To do this, we'll create a new action in our <c>photo_admin controller</c>. We'll call it <c>code_image</c>: </p>
<r>def code_image 
end</r>
<p>In this action, we'll get the <c>id</c> (primary key) of the image file we want to display, we'll pull it out of the database and then we'll send it to the browser and tell it to render it correctly. Let's expand:</p>
<r>def code_image 
    @image_data = Photo.find(params[:id]) 
    @image = @image_data.binary_data 
    send_data (@image, :type =&gt; @image_data.content_type, :filename =&gt; @image_data.filename, :disposition =&gt; 'inline') 
end</r>
<p>
Easy! In the above action we have: </p>
<ul>
<li>taken the <c>id</c> of the Photo from the <c>params</c> supplied by the form, and retrieved it from the database into the <c>@image_data</c> object</li>
<li>extracted the binary data out of the <c>binary_data</c> field</li>
<li>used Rails' <c>send_data</c> method to render the binary image to the browser</li>
</ul>
<p>
The <c>send_data</c> method can take several options: </p>

<ul>
<li><c>:filename</c> - suggests a filename for the browser to use</li>
<li><c>:type</c> - specifies an HTTP content type. Defaults to <c>application/octet-stream</c>. We've used the existing <c>content_type</c> information that was stored in the database when we saved the image</li>
<li><c>:disposition</c> - specifies whether the file will be shown inline or downloaded. Valid values are inline and attachment (default). We want the image displayed in the browser, so we've used inline.</li>
<li><c>:status</c> - specifies the status code to send with the response. Defaults to <c>200 OK</c>. We don't really need to worry about this today.</li>
</ul>

<p>Test it out: go to <c>yourapp/photo_admin/code_image/1</c> (or whatever the id is of the image you want to display - make sure it is in the database!). If all is well, your image should be rendered in the browser. </p>

<subhead>Displaying the image inline</subhead>

<p>Let's change the <c>show.rhtml</c> view for the <c>photo_admin controller</c>, so that instead of displaying a lot of gibberish, we can display the image itself under the "binary" column. If we open the <c>show.rhtml</c> view we should see the following:</p> 
    
<rh>&lt;% for column in Photo.content_columns %&gt;
    &lt;%= column.human_name %&gt;:
    &lt;%=h @photo.send(column.name) %&gt;
&lt;% end %&gt;</rh>
<p>
This code simply gets all of the column names from the database and their content and displays them automatically. This is fine for the text-based fields, but not for the binary image field. So we'll use an if condition to display the <c>binary_data</c> column differently:</p>
<rh>&lt;% for column in Photo.content_columns %&gt; 
    &lt;%= column.human_name %&gt;:
    &lt;% if column.name == "binary_data" %&gt;
        &lt;%= image_tag("/photo_admin/code_image/#{@photo.id}", :alt =&gt; "Image") %&gt; 
    &lt;% else %&gt;
        &lt;%=h @photo.send(column.name) %&gt; 
    &lt;% end %&gt;
&lt;% end %&gt;</rh>
<p>
Try it! Go to <c>yourapp/photo_admin/show/1</c> (or whatever the image id is you want to display) and your image should be displayed. In the above code, we're doing the following: </p>

<ul><li>looping through each column, and checking to see if the name of the column (<c>column.name</c>) is set to <c>binary_data</c></li>
<li>if it is, then we use the <c>image_tag</c> command to render an image. The URL of the image is simply the action that we just created in the <c>photo_admin</c> controller to encode and render the image: <c>photo_admin/code_image/id</c> where <c>id</c> is the "id" of the image, in this case stored in the <c>@photo.id</c> instance variable</li>
<li>if the column name isn't <c>binary_data</c>, we just display the standard content of the column as text</li>
</ul>
<p>So now you have the <c>code_image</c> method in your <c>photo_admin</c> controller, whenever you want to encode and render an image inline, you just call <c>photo_admin/code_image/id</c> as the image URL. Simple! </p>

<subhead>Troubleshooting Tips</subhead>
<p>
If you're getting <c>NoMethod</c> or other strange errors when uploading a file, try viewing the HTML of the new form after it has been rendered by your browser and before submitting it. Then you can make sure Rails is rendering the form correctly with the <c>multipart</c> entry. If you don't see multipart in the <c>&lt;form&gt;</c> tag, then that's your problem.</p>