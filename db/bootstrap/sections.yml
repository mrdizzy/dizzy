--- 
sections_020: 
  permalink: params-parsing-form-data
  content_id: "8"
  title: Parsing form data
  body: |
    ## Parsing form data
    
    When a form is submitted to a Rails application, the parameters are automatically translated by Rails into the `params` object which is accessible as a hash structure. 
    
    + Key/value pairs of your form's input fields are stored simply as key/value pairs in the params hash, such as the id which is extracted by routing from the URL:
    
    table:
    `/customers/1`              id=1	           `{ :id => "1" }`
    `/customers/1?color=red`    id=1&color=red       `{ :id => "1", :color => "red" }`
    
    
    + Square brackets [] are used to build more complex, nested structures:
    
    table:
    `text_field :user, :name`	          user[name]=David	`{ :user => { :name => "David" }`
    `text_field "user[address]", :city`	  user[address][city]=London	 `{ :user => { :address => { :city => "London" }}}`
    `text_field "user[address]", :street`	  user[address][street]=Road	`{ :user => { :address => { :street => "Road" }}}`
    
    
    + Using empty square brackets `[]` after the name of a model object, such as `address[]`, will insert the `id` of the record you are editing into the input field, useful for editing multiple records on one form:
    
    table:
    `text_field "address[]", :country`               address[4][country]=England               `{ :address => { 4 => { :country => "England" }}}`
    `text_field "address[]", :town`                  address[4][town]=London            `{ :address => { 4 => { :town => "London" }}}`
    
    
    + If the record is new and has no id, then upon submitting the form, Rails will convert the fields into an array of hashes in order of appearance:
    
    (Tab.1 Array of Hashes)
    
     
      ruby:
        text_field "address[]", :country 
        text_field "address[]", :town
        text_field "address[]", :country
        text_field "address[]", :town
    --------------------------------------------
      ruby:
        { :address => [
            { :country => "England", :town => "London" },
            { :country => "Australia", :town => "Sydney" }
          ]
        }
    
    

  id: "31"
  summary: how Rails parses incoming form data
sections_019: 
  permalink: form-for
  content_id: "8"
  title: form_for
  body: |
    ## form_for
    
    `form_for` is used to easily manipulate HTML forms which are based upon ActiveRecord model objects:
    
    rhtml:
        <%= form_for(:customer, @customer, :url => { :controller => "customers", :action => "create" }, :html => { :multipart => true, :method => :put }) do |f| %>
          <%= f.text_field :age %> 
          <%= text_field "customer", :age %>
          <%= submit_tag %>
        <% end %>
    
    ### Parameters
    
    table:
    `:customer` required        :symbol or "string"       The name of the model object for all the fields in the form. All input fields will be prefixed with this. Rails will also look for an `@instance_variable` with the same name which should contain an instance of an existing or new ActiveRecord model object
    `@customer` optional	     ActiveRecord model object	     If the `@instance_variable` containing the model object is named differently, you can pass a variable containing the actual model object here
    `:url` optional	           "string" or {hash}	     The URL to post the form to. Can take an explicit url as a string, or a hash in the same format as `url_for`
    `:html` optional	    {hash}	  A {hash} of HTML attributes which will be added to the HTML `<form>` tag.
    `:method` optional	    :symbol	   Pass as part of the {hash} of HTML attributes. Can be `:put`, `:post`, `:get` or `:delete`
    

  id: "30"
  summary: wrap ActiveRecord model objects in a form
sections_008: 
  permalink: delivering-email
  content_id: "13"
  title: Delivering email
  body: |
    ## Delivering mail
    
    Once a mailer action and template are defined, you can `deliver` your message or `create` and save it for delivery later by calling the mailer class and prefixing your chosen class method with `deliver_` or `create_`
    
    ### Send mail
    
    ruby:
        Notifier.deliver_signup_notification(customer)
    
    ### Create mail
    
    ruby:
        mail = Notifier.create_signup_notification(customer)
        Notifier.deliver(mail)
    
    You can pass the mailer model any variables you need to use in the generation of the email. In the example above we have passed it a variable named `customer` which could be an instance of an ActiveRecord `Customer` model. We can then access our customer's details in the mailer model.

  id: "14"
  summary: deliver emails or create and save them for future delivery
sections_010: 
  permalink: mailer-views
  content_id: "13"
  title: Views & Templates
  body: |
    ## Views & Templates
    
    Like ActionController, each mailer class has a corresponding view directory in which each method of the class looks for a template with its own name. For example...
    
    table:
    *Mailer model*    *Class method*           *Corresponding template*
    `Notifier`        `signup_notification`    `app/views/notifier/signup_notification.erb`
    `Notifier`          `despatch_alert`         `app/views/notifier/despatch_alert.erb`
    `MailingList`       `welcome_message`        `app/views/mailing_list/welcome_message.erb`
    

  id: "16"
  summary: each mailer has a corresponding view
sections_009: 
  permalink: how-to-send-multipart-messages
  content_id: "13"
  title: Multipart messages
  body: |-
    ## Multipart messages
    
    There are two ways to send multipart email messages, explicity by manually defining each part, and implicitly by letting ActionMailer do the donkey work.
    
    ### Explicitly
     
    You can explicitly define multipart messages using the part method...
    
    ruby:
        part "text/plain" do |p|
            p.body = render_message("signup-as-plain", :account => recipient)
            p.transfer_encoding = "base64"
        end
      
        part :content_type => "text/html", :body => render_message("signup-as-html", :account => recipient)
    
    ### Implicitly
    
    ActionMailer will automatically detect and use multipart templates, where each template is named after the name of the method, followed by the content type. Each such detected template will be added as a separate part to the message. For example:
    
    plain:
        signup_notification.text.plain.erb
        signup_notification.text.html.erb
        signup_notification.text.xml.builder
    
    Each would be rendered and added as a separate part to the message with the corresponding content type. The same body hash is passed to each template.
  id: "15"
  summary: how to send multipart messages
sections_011: 
  permalink: mailer-configuration-methods
  content_id: "13"
  title: Mailer Configuration Methods
  body: |
    ## Mailer Configuration Methods
    
    (Tab.1 Configuration Methods)
    
    *recipients* = [array] or "string"	
    ----------------------------------------------------------
    A string containing the email of address of the recipient, or an array of strings containing email addresses of multiple recipients. Will use the email's `To:` header.
    
    *sent_on* = Time object	 
    ----------------------------------------------------------
    A `Time` object which will be used to set the `Date:` header of the email. If not specified, then the current time and date will be used.
    
    *subject* = "string"	
    ----------------------------------------------------------
    The subject line to be used to set the email's `Subject:` header.
    
    *from* = [array] or "string"	 
    ----------------------------------------------------------
    A string containing the email address to appear on the `From:` line of the email being created, or a array of strings containing multiple email addresses in the same format as recipients.
    
    *body* = {hash}	
    ----------------------------------------------------------
    The body method sets instance variables to be available in the view template. For example, to make the variables order and name accessible as `@order` and `@name` respectively in your view template, use...
    
      ruby:
        body :order => order, :name => name
    
    *attachment* = {hash} or block	  
    ----------------------------------------------------------
    Enables you to add attachments to your email message.
    
      ruby:
        attachment :content_type => "image/jpeg", :body => File.read("an-image.jpg")
          attachment "application/pdf" do |a| 
            a.body = generate_your_pdf_here()
          end
    
    *bcc* = [array] or "string"	
    ----------------------------------------------------------
    Blind carbon copy recipients in the same format as `recipients`.
    
    *cc* = [array] or "string"
    ----------------------------------------------------------
    Carbon copy recipients in the same format as `recipients`
    
    *content_type* = "string"	 
    ----------------------------------------------------------
    Set the content type of the message. Defaults to `text/plain`
    
    *headers* = {hash}	
    ----------------------------------------------------------
    A hash containing name/value pairs to be converted into abitrary header lines. For example...
    
      ruby:
        headers "X-Mail-Count" => 107370
    
    *mime_version* = "string"	
    ----------------------------------------------------------
    The mime version for the message. Defaults to `1.0`
    
    *charset* = "string"	
    ----------------------------------------------------------
    The charset for the body and to encode the subject. Defaults to `UTF-8`
    
    *implicit_parts_order* = [array]	
    ----------------------------------------------------------
    When an email is built implicitly, this variable controls how the parts are ordered. Defaults to `["text/html", "text/enriched", "text/plain"]`. Items that appear first in the array have higher priority in the receiving mail client and appear last in the mime encoded message.

  id: "17"
  summary: use in your mailer model to define an email
sections_012: 
  permalink: mailer-url-generation
  content_id: "13"
  title: URL Generation
  body: |-
    ## URLs
    
    If your view includes URLs from the application, you need to use `url_for` in the mailer class method instead of in the view template. You can pass the result to the view via the `body` method. Unlike controllers from ActionPack, the mailer instance doesn't have any context about the incoming request. 
    
    ruby:
        body :home_page => url_for(:host => "dizzy.co.uk", :controller => "welcome", :action => "index")
  id: "23"
  summary: generate URLs to be used in your mailer view template
sections_001: 
  permalink: rails-migrations-methods
  content_id: "1"
  title: Methods
  body: |
    ## Methods
    
    ### add_column
    
    Creates a new column on the specified table.
    
    ruby:
        add_column :table_name, :column_name, :column_type, { options }
    
    + `:null => true` or `false` - if `false`, the underlying column has a `NOT NULL` constraint added by the database engine
    + `:limit => size` - set a `limit` on the `size` of the field
    + `:default => value` - set a default `value` for the column
    
    ### add_index
    
    Creates an index for the specified table, the name of which defaults to `table_column_index`
    
    ruby:
        add_index :table_name, :column_name, :unique => true, :name => "chosen_index_name"
    
    ### change_column
    
    Change the data type of the specified column
    
    ruby:
        change_column :table_name, :column_name, :new_type, { options as add_column }
    
    ### create_table
    
    Creates a table on the database. Creates a table called `:table_name` and makes the table object available to a block that can then add columns to it, following the same format as `add_column`.
    ruby:
        create_table :table_name, { options } do |t|
          t.column :column_name, :column_type, :options
        end
    
    + `:force => true` - forces drop of an existing table of the same name before creation the new one
    + `:temporary => true` - creates a temporary table, one that goes away when the application disconnects from the database
    + `:id => false` - defines a table with no primary key, for example when you need to define a join table
    + `:primary_key => :new_primary_key_name` - overrides the default name of `id` for the primary column, use this to specify the name of the column in the database that Rails will use to store the primary key
    + `:options => ""` - lets you specify options to your underlying database, e.g. `"auto_increment = 10000"`. Will lose default `"ENGINE=InnoDB statement"`.
    
    ### execute
    
    Takes a single string identifying a valid SQL command to execute directly
    
    ruby:
        execute "alter table line_items add constraint fk_line_item_products foreign key (product_id) references products(id)"
    
    ### IrreversibleMigration
    
    Use in the down method of a migration file to raise an exception when the `up` methods of the same migration file can not be reversed, e.g. changing a column type from `:integer` to `:string`
    
    ruby:
        raise ActiveRecord::IrreversibleMigration
    
    ### rename_table
    
    Renames the specified table.
    
    ruby:
        rename_table :new_table_name, :old_table_name
    
    ### rename_column
    
    Renames the old_column_name to new_column_name
    
    ruby:
        rename_column :old_column_name, :new_column_name
    
    ### rename_table
    
    Renames the specified table.
    
    ruby:
        rename_table :new_table_name, :old_table_name
    
    ### remove_index
    
    Remove an index for the specified table.
    
    ruby:
        remove_index :table_name, :column_name

  id: "1"
  summary: interact with your database using migration methods
sections_013: 
  permalink: configuring-action-mailer
  content_id: "13"
  title: ActionMailer Configuration
  body: |
    ## ActionMailer::Base Configuration Methods
    
    ActionMailer is configured by acessing configuration methods at the class level, for example, `ActionMailer::Base.template_root = "/my/templates"`. These methods allow you to define the overall settings to be used by your application whenever it invokes ActionMailer. Define these settings in your `config/environment.rb` file using `config.action_mailer.method_name_here`. If you require different settings for each of your Rails' environments, define settings separately via `config/environments`.
    
    (Tab.1 Configuration Methods)
    
    *smtp_settings* = {hash}
    --------------------------------------------------
      `:address` - the address of the SMTP server you will be using to send email. Defaults to `localhost`
    
      `:port` - the port number of the SMTP server you will be using. Defaults to `25`
    
      `:domain` - if you need to specify a `HELO` domain, you can do it here
    
      `:user_name` - if your mail server requires authentication, set the username in this variable
    
      `:password` - if your mail server requires authentication, set the password in this variable
    
      `:authentication` - if your mail server requires authentication, you need to specify the authentication type here. This is a symbol, and one of `:plain`,       `:login`, or `:cram_md5`
    
    *sendmail_settings* = {hash}
    --------------------------------------------------
    `:location` - the location of the sendmail executable, defaults to `/usr/sbin/sendmail`
    `:arguments` - the command line arguments for sendmail
    
    *raise_delivery_errors* = true or false
    --------------------------------------------------
    Whether or not errors should be raised if the email fails to be delivered.
    
    *delivery_method* = :smtp, :sendmail or :test
    --------------------------------------------------
    Defines a delivery method, defaults to `:smtp`
    
    *perform_deliveries* = true or false
    --------------------------------------------------
    Determines whether deliver_* methods are actually carried out. By default they are, but this can be turned off to help functional testing.
    
    *template_root* = "/path"
    --------------------------------------------------
    The root from which template references will be made
    
    *logger* 
    --------------------------------------------------
    Used for generation information on the mailing run if available. Can be set to `nil` for no logging. Compatible with Ruby's own Logger and Log4r loggers.
    
    *default_charset* = "string"
    --------------------------------------------------
    the default charset used for the body and to encode the subject. Defaults to `UTF-8`. You can also pick a different charset from inside a mailer method by setting charset
    
    *default_mime_version* = "string"
    --------------------------------------------------
    The default mime version used for the message. Defaults to `1.0`. You can also pick a different value from inside a mailer method by setting `mime_version`
    
    *default_implicit_parts_order* = [array]
    --------------------------------------------------
    When an email is built implicitly, this variable controls how the parts are ordered. Defaults to `["text/html", "text/enriched", "text/plain"]`. Items that appear first in the array have higher priority in the receiving mail client and appear last in the mime encoded message. You can also pick a different value from inside a mailer method by setting `implicit_parts_order`
    
    *default_content_type* = "string"
    --------------------------------------------------
    The default content type used for the main part of the message. Defaults to `text/plain`. You can also pick a different value from inside a mailer method by setting `content_type`

  id: "24"
  summary: configure Action Mailer
sections_002: 
  permalink: database-mapping
  content_id: "1"
  title: Database mapping
  body: |
    ## Database Mapping
    
    table:
    *Rails*      *db2*	   *mysql*	   *openbase*   *Oracle*
    `:binary`    blob(32678)   blob		   object	 blob
    `:boolean`   decimal(1)    tinyint(1)	   boolean	 number(10)
    `:date`      date	   date		   date		 date
    `:datetime`  timestamp     datetime	   datetime	 date
    `:decimal`   decimal       decimal         decimal	 decimal
    `:float`     float         float	   float	 number
    `:integer`   int	   int(11)         integer	 number(38)
    `:string`    varchar(255)  varchar(255)    char(4096)    varchar2(255)
    
    table:
    *Rails*      *postgresql*  *sqlite*      *sqlserver*     *Sybase*
    `:binary`    bytea         blob          image           image
    `:boolean`   boolean       boolean       bit             bit
    `:date`      date          date          datetime        datetime
    `:datetime`  timestamp     datetime      datetime        datetime
    `:decimal`   decimal       decimal       decimal         decimal
    `:float`     float         float         float(8)        float(8)
    `:integer`   integer       integer       int             int
    `:string`    \*            varchar(255)  varchar(255)    varchar(255)

  id: "2"
  summary: how migration column types map to your underlying database
sections_014: 
  permalink: example-form-for
  content_id: "8"
  title: Example
  body: |
    ## Example
    
    ### Controller
    
    ruby:
        def new
          @customer = Customer.new
          3.times do 
            @customer.addresses.build	
          end
        end
    
    ### View
    
    rhtml:
        <% form_for(@customer) do |f| %>
          <%= f.text_field :name %>
          <%= f.text_field :email %>
          <% @customer.addresses.each do |address| %>
            <% fields_for "customer[addresses][]", address do |fields| %>
              <%= fields.text_field :number %>
        	  <%= fields.text_field :street %>
          <% end %>
        <% end %>
    
    ### HTML
    
    rhtml:
        <form id="new_customer" class="new_customer" method="post" action="/customers">
        <input type="text" size="30" name="customer[name]"/>
        <input type="text" size="30" name="customer[email]"/>
        <input type="text" size="30" name="customer[addresses][][number]"/>
        <input type="text" size="30" name="customer[addresses][][street]"/>
        <input type="text" size="30" name="customer[addresses][][number]"/>
        <input type="text" size="30" name="customer[addresses][][street]"/>
        <input type="text" size="30" name="customer[addresses][][number]"/>
        <input type="text" size="30" name="customer[addresses][][street]"/>
        <input type="submit" value="Create" name="commit"/>
        </form>
    
    ### params[]
    
    ruby:
        params = {
          "customer" => { "name"=>"David Pettifer",
                          "email"=>"david.p@dizzy.co.uk",
                          "addresses"=> [
                            { "number"=>"31", "street"=>"High" },
                            { "number"=>"22", "street"=>"Brook" },
                            { "number"=>"16", "street"=>"Kents" }  ]
                       } }

  id: "25"
  summary: controller, view, HTML and params[]
sections_003: 
  permalink: example-migration-file
  content_id: "1"
  title: Example migration
  body: |-
    ## Example migration file
    
    ruby:
        class CreateCustomers < ActiveRecord::Migration
    
        def self.up
            # Create "Customers" table
            create_table :customers, :primary_key => :customer_id, :options => "auto_increment = 10000" do |t|
              # Add columns to "Customers" table
              t.column :customer_id, :integer
              t.column :name,        :string,    :limit => 30, :null => false
              t.column :age,         :integer
              t.column :premium,     :boolean,   :default => 0
              t.column :photo,       :binary,    :limit => 2.megabytes
              t.column :thumbnail,   :binary,    :limit => 256.kilobytes
              t.column :dob,         :date,      :null => false
              t.column :created_at,  :timestamp
              t.column :notes,       :text,      :default => "No notes recorded"
          end
          # Add "surname" column to "Customers" table 
          add_column :customers, :surname,   :string,   :limit => 50
          # Add "price" column to "Orders" table
          add_column :orders,    :price,     :decimal,  :precision => 8, :scale => 2
          # Create a record on the "Customers" table
          Customer.create :name => "David", :surname => "Smith", :age => "32", :premium => "1", :notes => "One of our top customers!"
        end
    
        def self.down 
          # Delete the "Customers" table
            drop_table :customers
          end
        end
  id: "3"
  summary: What a migration file looks like
sections_015: 
  permalink: fields-for
  content_id: "8"
  title: fields_for
  body: |-
    ##fields_for
    
    `fields_for` creates a scope around a specific model object like `form_for`, but doesn't create the form tags themselves, making `fields_for` suitable for specifying additional model objects in the same form. See the example.
  id: "26"
  summary: creates a scope around fields
sections_004: 
  permalink: rake-tasks
  content_id: "1"
  title: Rake tasks
  body: |-
    ## Rake tasks
    
    (Tab.1 Rake Tasks)
    
    Generate migration              
    -----------------------------------------
      `ruby script/generate migration your_chosen_migration_name`
    
    run all unapplied migrations    
    -----------------------------------------
      `rake db:migrate`
    
    migrate database to specific version    
    -----------------------------------------
     `rake db:migrate VERSION=18`
    
    use your migrations to recreate the tables in the testing or production databases
    ---------------------------------------------------------------------------------
      `rake db:migrate RAILS_ENV=production`
    
    Create a `db/schema.rb` file that can be portably used against any database supported by ActiveRecord
    -------------------------
      `rake db:schema:dump`
    
    Load a `schema.rb` file into the database
    -----------------------------------------
      `rake db:schema:load`
    
    Loads a `schema.rb` file into the database and then loads the initial database fixtures.
    -----------------------------------------
      `rake db:bootstrap`
  id: "4"
  summary: a list of built-in migration-related Rake tasks
sections_016: 
  permalink: multipart-form
  content_id: "8"
  title: Multipart form
  body: |
    ## Multipart form
    
    ### View
    
    rhtml:
        <% form_for(@customer, :html => { :multipart => true }) do |f| %>
          <%= f.file_field :image_file %>
        <%= submit_tag %>
        <% end %>
    
    ### Model
    
    ruby:
        class Customer < ActiveRecord::Base
          def image_file      =(uploaded_data)
            self.filename     = uploaded_data.original_filename
            self.image_data   = uploaded_data.read
            self.size     	  = uploaded_data.size
            self.content_type = uploaded_data.content_type	
          end
        end

  id: "27"
  summary: model and view of multipart form
sections_005: 
  permalink: directory-structure
  content_id: "1"
  title: Directory Structure
  body: |-
    ## Directory structure
    
    + rails_root
        + db
            + schema.rb
            + migrate
                + 001_create_customers
                + 002_add_photo
                + 003_alter_surname
  id: "5"
  summary: where migration files go
sections_017: 
  permalink: input-field-helpers
  content_id: "8"
  title: Input field helpers
  body: |
    ## Input field helpers
    
    ruby:
        f.error_messages_for
        f.check_box :terms, { :class => 'check' }, "yes", "no"
        f.file_field :image
        f.hidden_field :id
        f.label :customer, "Text for label"
        f.password_field :password
        f.radio_button :language, "French"
        f.text_area :comment, :size => "20x30", :disabled => "disabled"
        f.text_field :age, :size => "20", :class => "age_box"

  id: "28"
  summary: check boxes, text fields, radio buttons
sections_006: 
  permalink: test-section-link
  content_id: "1"
  title: Test section
  body: Testing a new section.
  id: "6"
  summary: testing a new section
sections_018: 
  permalink: restful-form-for
  content_id: "8"
  title: RESTful form_for
  body: |
    ## RESTful form_for
    
    When standard routes are used in a RESTful context, Rails will reflect upon the object passed to it and  automatically build a form with the relevant RESTful URL depending on whether the form is wrapping a new record (create) or an existing record (update). Nested routes will require you to be more verbose. Standard routes	
    
    table:
    *Standard routes*            *new record?*    *method*         *URL*
    `form_for(@customer)`        yes	      POST	       `/customers`
    `form_for(@customer)`	     no               PUT	       `/customers/1`
    *Nested routes*            *new record?*    *method*         *URL*
    `form_for(@address, :url => customer_addresses_path(@customer))`   	yes     POST	`/customers/1/addresses`
    `form_for(@address, :url => customer_addresses_path(@customer))`	no	PUT	  `/customers/1/addresses/24`
    

  id: "29"
  summary: using form_for in a RESTful context
sections_007: 
  permalink: mailer-model
  content_id: "13"
  title: Mailer Model
  body: |
    ## Mailer Model
    
    To use ActionMailer, you need to create a mailer model. Emails are defined by creating methods within the mailer model which are then used to set variables to be used in the mail template, to change options on the mail, or to add attachments.
    
    ### Mailer model generator
    
    plain:
        ruby script/generate mailer NameOfMailer method1 method2 method3 
     
    ### Example mailer model
    ruby:
        class OrderMailer < ActionMailer::Base
          
            def confirm(order,sent_at = Time.now)
                subject    "Subject line goes here"
                body       :order => order
                recipients ["bill@microsoft.com", "steve@apple.com"]
                from       "david@dizzy.co.uk"
                sent_on    sent_at
            end    
        end

  id: "13"
  summary: emails are defined by creating methods within the mailer model
