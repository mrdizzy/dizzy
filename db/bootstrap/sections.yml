--- 
sections_008: 
  permalink: form_for_fields_for_helpers_builders
  content_id: "4"
  title: form_for and fields_for
  body: "<subhead>form builders that wrap model objects</subhead>\r\n\
    \r\n\
    <minihead>form_for</minihead>\r\n\
    \r\n\
    <r>  form_for(:object, @object_instance, {options}) </r>\r\n\
    \r\n\
    <sample_code aid:trows=\"2\" aid:tcols=\"2\">\r\n\
    \t<Cell><p>Code</p></Cell>\r\n\
    \t<Cell><rh>&lt;% form_for (:person, @person, :url =&gt; { :action =&gt; &apos;update&apos;, :id =&gt; 1 }, :html =&gt; { :multipart =&gt; :true}) do  |form|%&gt;  </rh>\r\n\
    <rh>  Name:    &lt;%= form.text_field  :title, :size =&gt; 30 %&gt; </rh><rh>  Notes:   &lt;%= form.text_area  :content, :size =&gt; &quot;10x20&quot; %&gt; </rh><rh>  Photo:   &lt;%= form.file_field   :photo_data %&gt; </rh><rh>  &lt;%= submit_tag &quot;Update&quot; %&gt; </rh>\r\n\
    <rh>&lt;% end %&gt;</rh></Cell>\r\n\
    \r\n\
    \t<Cell><p>Output</p></Cell>\r\n\
    \t<Cell><rh>&lt;form action=&quot;/user/update/1&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;  </rh>\r\n\
    <rh> Name:  &lt;input id=&quot;person_title&quot; name=&quot;person[title]&quot; size=&quot;30&quot; type=&quot;text&quot; /&gt; </rh><rh> Notes: &lt;textarea cols=&quot;10&quot; id=&quot;person_content&quot; name=&quot;person[content]&quot; rows=&quot;20&quot;&gt;&lt;/textarea&gt; </rh><rh> Photo: &lt;input id=&quot;person_photo_data&quot; name=&quot;person[photo_data]&quot; type=&quot;file&quot; /&gt; </rh><rh>  &lt;input name=&quot;commit&quot; type=&quot;submit&quot; value=&quot;Update&quot; /&gt; </rh>\r\n\
    <rh>&lt;/form&gt;</rh>\r\n\
    </Cell>\r\n\
    </sample_code>\r\n\
    \r\n\
    <minihead>fields_for </minihead>\r\n\
    \r\n\
    <r>  fields_for(:object, @object_instance) </r>\r\n\
    \r\n\
    <sample_code aid:trows=\"2\" aid:tcols=\"2\">\r\n\
    \t<Cell><p>Code</p></Cell>\r\n\
    \t<Cell><rh>&lt;% fields_for :phone, @phone do |phone_fields| %&gt;  </rh><rh>    Home:   &lt;%= phone_fields.text_field :home %&gt; </rh><rh>    Work:   &lt;%= phone_fields.text_field :work %&gt; </rh><rh>    Cell:   &lt;%= phone_fields.text_field :cell %&gt;   </rh><rh>&lt;% end %&gt;</rh></Cell>\r\n\
    <Cell><p>Output</p></Cell>\r\n\
    <Cell><rh>Home: &lt;input id=&quot;phone_home&quot; name=&quot;phone[home]&quot; type=&quot;text&quot; /&gt; </rh><rh>Work: &lt;input id=&quot;phone_work&quot; name=&quot;phone[work]&quot; type=&quot;text&quot; /&gt; </rh><rh>Cell: &lt;input id=&quot;phone_cell&quot; name=&quot;phone[cell]&quot; type=&quot;text&quot; /&gt;</rh></Cell></sample_code> "
  id: "8"
  summary: form builders that wrap model objects
sections_010: 
  permalink: permalink
  content_id: "5"
  title: Paragraphs and Line Breaks
  body: "### Paragraphs and Line Breaks\r\n\
    \r\n\
    A paragraph is simply one or more consecutive lines of text, separated by one or more blank lines. (A blank line is any line that looks like a blank line \xE2\x80\x94 a line containing nothing but spaces or tabs is considered blank.) Normal paragraphs should not be indented with spaces or tabs.\r\n\
    \r\n\
    A paragraph will become wrapped in `<p></p>` tags during conversion.\r\n\
    \r\n\
    ### Headers\r\n\
    \r\n\
    table:\r\n\
    `This is an H1`<br/>`=============`   `<h1>This is an H1</h1>`\r\n\
    `This is an H2`<br/>`-------------`   `<h2>This is an H2</h2>`\r\n\
    `# This is also an H1`                `<h1>This is also an H1</h1>`\r\n\
    `## This is also an H2`               `<h2>This is also an H2</h2>`\r\n\
    `### This is an H3`                   `<h3>This is an H3</h3>`\r\n\
    \r\n\
    Pre-formatted code blocks are used for writing about programming or markup source code. Rather than forming normal paragraphs, the lines of a code block are interpreted literally. Markdown wraps a code block in both `<pre>` and `<code>` tags.\r\n\
    \r\n\
    ### Code Blocks\r\n\
    \r\n\
    To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab.\r\n\
    \r\n\
    <table>\r\n\
    <tr><td><b>Input</b></td><td><b>Output</b></td></tr>\r\n  <tr>\r\n    <td><pre>This is a normal paragraph.\r\n    \r\n        @array  = [1,2,3,4,5]\r\n        $string = \"James Brown\"\r\n        @array.each { |array| array + 3 }</pre>\r\n\
    </td>\r\n\
    <td>\r\n\
    <pre>&lt;p&gt;This is a normal paragraph.&lt;/p&gt;\r\n\
    \r\n        &lt;pre&gt;@array  = [1,2,3,4,5]\r\n        $string = \"James Brown\"\r\n        @array.each { |array| array + 3 }&lt;/code&gt;&lt;/pre&gt;\r\n\
    </td>\r\n\
    </tr>\r\n\
    </table>\r\n\
    \r\n\
    To produce a code block in Markdown, simply indent every line of the block by at least 4 spaces or 1 tab. For example, given this input:"
  id: "10"
  summary: Syntax
sections_009: 
  permalink: select-menu-helpers
  content_id: "4"
  title: Select helpers
  body: "<subhead>Select field helpers </subhead>\r\n\
    \r\n\
    <minihead>collection_select </minihead>\r\n\
    \r\n\
    <r> collection_select(:object, :method, [collection], :option_key_method, :option_value_method, {options}, {html_options}) </r>\r\n\
    \r\n\
    <sample_code aid:trows=\"2\" aid:tcols=\"2\">\r\n\
    \t<Cell><p>Code:</p></Cell>\r\n\
    \t<Cell><r>@users = User.find(:all, :order =&gt; &quot;name&quot;) </r><r>collection_select(:user, :id, @users, :id, :name, {}, :class =&gt; &quot;red&quot;)</r></Cell>\r\n\
    \r\n\
    \t<Cell><p>Output:</p></Cell>\r\n\
    \t<Cell><rh>&lt;select id=&quot;user_id&quot; name=&quot;user[id]&quot; class=&quot;red&quot;&gt; </rh><rh>&lt;option value=&quot;#{@user.id}&quot;&gt;#{@user.name}&lt;/option&gt;&lt;/select&gt;</rh></Cell>\r\n\
    </sample_code> \r\n\
    \r\n\
    <minihead>option_groups_from_collection_for_select </minihead>\r\n\
    \r\n\
    <r> option_groups_from_collection_for_select([collection], :group_method, :group_label_method, :option_key_method, :option_value_method, :selected_key) </r>\r\n\
    \r\n\
    <sample_code aid:trows=\"2\" aid:tcols=\"2\">\r\n\
    \t<Cell><p>Code:</p></Cell>\r\n\
    \t<Cell><r>option_groups_from_collection_for_select(@authors, :books, :name, :id, :title, 3)</r></Cell>\r\n\
    \r\n\
    \t<Cell><p>Output:</p></Cell>\r\n\
    \t<Cell><rh>&lt;optgroup label=&quot;J K Rowling&quot;&gt; </rh><rh>    &lt;option_ value=&quot;1&quot;&gt;Harry Potter: Order of the Phoenix&lt;/option&gt; </rh><rh>    &lt;option value=&quot;4&quot;&gt;Harry Potter: The Deathly Hallows&lt;/option&gt; </rh><rh>&lt;/optgroup&gt; </rh><rh>&lt;optgroup label=&quot;Douglas Coupland&quot;&gt; </rh><rh>    &lt;option value=&quot;3&quot; selected=&quot;selected&quot;&gt;Generation X&lt;/option&gt; </rh><rh>    &lt;option value=&quot;12&quot;&gt;Girlfriend In A Coma&lt;/option&gt; </rh><rh>    &lt;option value=&quot;5&quot;&gt;Shampoo Planet&lt;/option&gt; </rh><rh>&lt;/optgroup&gt;</rh></Cell>\r\n\
    </sample_code> \r\n\
    \r\n\
    <minihead>options_for_select </minihead>\r\n\
    \r\n\
    <r>options_for_select([{choices}], [selected]) </r>\r\n\
    \r\n\
    <sample_code aid:trows=\"2\" aid:tcols=\"2\">\r\n\
    \t<Cell><p>Code:</p></Cell>\r\n\
    \t<Cell><r>options_for_select( {&quot;Mary&quot; =&gt; &quot;\xC2\xA32&quot;, &quot;Lucy&quot; =&gt; &quot;\xC3\x82\xC2\xA34&quot; ,&quot;Anne&quot; =&gt; &quot;\xC2\xA36&quot;}, [&quot;\xC2\xA34&quot;, &quot;\xC3\x82\xC2\xA36&quot;])</r></Cell>\r\n\
    \t\r\n\
    \t<Cell><p>Output:</p></Cell>\r\n\
    \t<Cell><rh>&lt;option value=&quot;\xC3\x82\xC2\xA32&quot;&gt;Mary&lt;/option&gt; </rh><rh>&lt;option value=&quot;\xC3\x82\xC2\xA34&quot; selected=&quot;selected&quot;&gt;Lucy&lt;/option&gt;  </rh><rh>&lt;option value=&quot;\xC3\x82\xC2\xA36&quot; selected=&quot;selected&quot;&gt;Anne&lt;/option&gt;</rh></Cell>\r\n\
    </sample_code> \r\n\
    \r\n\
    <minihead>options_from_collection_for_select </minihead>\r\n\
    \r\n\
    <r> options_from_collection_for_select([collection], :value_method, :text_method, [selected]) </r>\r\n\
    \r\n\
    <sample_code aid:trows=\"2\" aid:tcols=\"2\">\r\n\
    \t<Cell><p>Code:</p></Cell>\r\n\
    \t<Cell><r>options_from_collection_for_select(@authors, :id, :name)</r></Cell>\r\n\
    \r\n\
    \t<Cell><p>Output:</p></Cell>\r\n\
    \t<Cell><rh>&lt;option value=&quot;#{@author.id}&quot;&gt;#{@author.name}&lt;/option&gt;</rh></Cell>\r\n\
    </sample_code> \r\n\
    \r\n\
    <minihead>select </minihead>\r\n\
    \r\n\
    <r> select(:object_name, :method, [choices], {options}, {html_options}) </r>\r\n\
    \r\n\
    <sample_code aid:trows=\"2\" aid:tcols=\"2\">\r\n\
    \t<Cell><p>Code:</p></Cell>\r\n\
    \t<Cell><r>@people = Person.find(:all).collect { |p| [p.name, p.id] ) </r><r>select(:post, :person_id, @people, {:include_blank =&gt; true})</r></Cell>\r\n\
    \r\n\
    \t<Cell><p>Output:</p></Cell>\r\n\
    \t<Cell><rh>&lt;select name=&quot;post[person_id]&quot;&gt; </rh><rh> &lt;option value=&quot;&quot;&gt;&lt;/option&gt; </rh><rh> &lt;option value=&quot;1&quot; selected=&quot;selected&quot;&gt;David&lt;/option&gt; </rh><rh> &lt;option value=&quot;2&quot;&gt;Sam&lt;/option&gt;&lt;/select&gt;</rh></Cell>\r\n\
    </sample_code> "
  id: "9"
  summary: helpers that build drop-down &lt;select&gt; forms
sections_011: 
  permalink: summary
  content_id: "5"
  title: Test new section
  body: |
    So here is my pretty in pink document. I am just outlining various details. 
    So today, we're going to talk about bullshit. 
    
    (Tab.1 Regular Expressions)
    
    product(force_reload=false)
    ----------------------------------
      Return the *associated* product (or nil if no associated product exists). The result is cached, and the database will not be queried againn when this association is subsequently used unless true is passed as a parameter. 
    
      Most commonly this method is called as if it were a simple attribute of (say) a line item object
    
    product=obj
    ----------------------------------
      *Associate* this line item with the given product, setting the product_id column in this line item to the product's primary key. If the product has not been saved, it will be when the line item is saved, and the keys will be linked at that time. 
    
    build_product(attributes={})
    ------------------------------------
      Don't be so `silly` norman.
    
    create_product(attributes={})
    -----------------------------------
      Build a new product object, link this line item to it, and save the product.
    
    

  id: "11"
  summary: test summary
sections_012: 
  permalink: character-representations
  content_id: "5"
  title: Character Representations
  body: |
    ## Character representations
    
    table:
    \a        Alert (bell), \x07.
    \b        Backspace, \x08, supported only in character class.
    \e        ESC character, \x1B.
    \n        Newline, \x0A.
    \r        Carriage return, \x0D.
    \f        Form feed, \x0C.
    \t        Horizontal tab, \x09.
    \v        Vertical tab, \x0B.
    \0octal   Character specified by a two-digit octal code.
    \xhex     Character specified by a two-digit hexadecimal code.
    \cchar    Named control character.
    

  id: "12"
  summary: none
sections_001: 
  permalink: rails-migrations-methods
  content_id: "1"
  title: Methods
  body: |
    ## Methods
    
    ### add_column
    
    Creates a new column on the specified table.
    
    ruby:
        add_column :table_name, :column_name, :column_type, { options }
    
    + :null => true or false - if false, the underlying column has a not null constraint added by the database engine
    + :limit => size - set a limit on the size of the field
    + :default => value - set a default value for the column
    
    ### add_index
    
    Creates an index for the specified table, the name of which defaults to table_column_index.
    
    ruby:
        add_index :table_name, :column_name, :unique => true, :name => "chosen_index_name"
    
    ### change_column
    
    Change the data type of the specified column
    
    ruby:
        change_column :table_name, :column_name, :new_type, { options as add_column }
    
    ### create_table
    
    Creates a table on the database. Creates a table called :table_name and makes the table object available to a block that can then add columns to it, following the same format as add_column.
    ruby:
        create_table :table_name, { options } do |t|
          t.column :column_name, :column_type, :options
        end
    
    + :force => true - forces drop of an existing table of the same name before creation the new one
    + :temporary => true - creates a temporary table, one that goes away when the application disconnects from the database
    + :id => false - defines a table with no primary key, for example when you need to define a join table
    + :primary_key => :new_primary_key_name - overrides the default name of :id for the primary column, use this to specify the name of the column in the database that Rails will use to store the primary key
    + :options => "" - lets you specify options to your underlying database, e.g. "auto_increment = 10000". Will lose default "ENGINE=InnoDB statement".
    
    ### execute
    
    Takes a single string identifying a valid SQL command to execute directly
    
    ruby:
        execute "alter table line_items add constraint fk_line_item_products foreign key (product_id) references products(id)"
    
    ### IrreversibleMigration
    
    Use in the down method of a migration file to raise an exception when the up methods of the same migration file can not be reversed, e.g. changing a column type from :integer to :string.
    
    ruby:
        raise ActiveRecord::IrreversibleMigration
    
    ### rename_table
    
    Renames the specified table.
    
    ruby:
        rename_table :new_table_name, :old_table_name
    
    ### rename_column
    
    Renames the old_column_name to new_column_name
    
    ruby:
        rename_column :old_column_name, :new_column_name
    
    ### rename_table
    
    Renames the specified table.
    
    ruby:
        rename_table :new_table_name, :old_table_name
    
    ### remove_index
    
    Remove an index for the specified table.
    
    ruby:
        remove_index :table_name, :column_name
    

  id: "1"
  summary: interact with your database using migration methods
sections_013: 
  permalink: character-classes
  content_id: "5"
  title: Character classses
  body: |
    ## Character classes
    
    table:
    *Class*     *Meaning*
    [...]       A single character listed, or contained within a listed range
    [^...]      A single character not listed, and not contained within a listed range
    . 			Any character, except a line terminator (unless single-line mode, s)
    \w          Word character
    \W          Nonword character
    \d          Digit
    \D          Nondigit
    \s          Whitespace character, [ \f\n\r\t\v]
    \S          Nonwhitespace character, [^ \f\n\r\t\v]

  id: "13"
  summary: Character classes
sections_002: 
  permalink: database-mapping
  content_id: "1"
  title: Database mapping
  body: |
    ## Database Mapping
    
    table:
    *Rails*      *db2*	   *mysql*	   *openbase*   *Oracle*
    `:binary`    blob(32678)   blob		   object	 blob
    `:boolean`   decimal(1)    tinyint(1)	   boolean	 number(10)
    `:date`      date	   date		   date		 date
    `:datetime`  timestamp     datetime	   datetime	 date
    `:decimal`   decimal       decimal         decimal	 decimal
    `:float`     float         float	   float	 number
    `:integer`   int	   int(11)         integer	 number(38)
    `:string`    varchar(255)  varchar(255)    char(4096)    varchar2(255)
    
    table:
    *Rails*      *postgresql*  *sqlite*      *sqlserver*     *Sybase*
    `:binary`    bytea         blob          image           image
    `:boolean`   boolean       boolean       bit             bit
    `:date`      date          date          datetime        datetime
    `:datetime`  timestamp     datetime      datetime        datetime
    `:decimal`   decimal       decimal       decimal         decimal
    `:float`     float         float         float(8)        float(8)
    `:integer`   integer       integer       int             int
    `:string`    \*            varchar(255)  varchar(255)    varchar(255)
    

  id: "2"
  summary: how migration column types map to your underlying database
sections_014: 
  permalink: regex-instance-methods
  content_id: "5"
  title: Instance Methods
  body: |
    ## Instance methods
    
    (Tab.1 Instance Methods)
    
    `string =~ regexp`
    `=> fixnum or nil`
    ---------------------------------
      Match the regexp, and return the position that the match starts, or `nil`
    
    `regexp === string => boolean`
    ---------------------------------
      Return `true` if the regexp matches the string. Used in case when statements
    
    `gsub(pattern, replacement) => new_string`
    `gsub(pattern) {|match| block } => new_string`
    ---------------------------------------------
      Return a copy of string with all occurrences of pattern replaced with replacement, or the value of the block. Otherwise, behaves as `Regexp#sub`
    
    `gsub!(pattern, replacement) => string or nil`
    `gsub!(pattern) {|match| block } => string or nil`
    --------------------------------------------------
      Perform the substitutions of `String#gsub` in place, returning `string` or returning `nil` if no substitutions were performed
    
    `index(regexp [, offset]) => fixnum or nil`
    ----------------------------------------------
      Return the index of the first match by `regexp` or `nil` if not found. Optionally, offset specifies the position in the string to begin the search.
    
    `match(pattern) => matchdata or nil`
    ----------------------------------------------
      Apply a regex pattern or `Regexp` object to the string, returning a `MatchData` object, or returning `nil` if there was no match.
    
    `rindex(regexp [, fixnum]) => fixnum or nil`
    ----------------------------------------------
      Return the index of the first match by regexp or `nil` if not found. Optionally, offset specifies the position in the string to end the search; characters to the right of this point will not be considered.

  id: "14"
  summary: Instance Methods
sections_003: 
  permalink: example-migration-file
  content_id: "1"
  title: Example migration
  body: |
    ## Example migration file
    
    ruby:
        class CreateCustomers < ActiveRecord::Migration
    
        def self.up
            # Create "Customers" table
            create_table :customers, :primary_key => :customer_id, :options => "auto_increment = 10000" do |t|
              # Add columns to "Customers" table
              t.column :customer_id, :integer
              t.column :name,        :string,    :limit => 30, :null => false
              t.column :age,         :integer
              t.column :premium,     :boolean,   :default => 0
              t.column :photo,       :binary,    :limit => 2.megabytes
              t.column :thumbnail,   :binary,    :limit => 256.kilobytes
              t.column :dob,         :date,      :null => false
              t.column :created_at,  :timestamp
              t.column :notes,       :text,      :default => "No notes recorded"
          end
          # Add "surname" column to "Customers" table 
          add_column :customers, :surname,   :string,   :limit => 50
          # Add "price" column to "Orders" table
          add_column :orders,    :price,     :decimal,  :precision => 8, :scale => 2
          # Create a record on the "Customers" table
          Customer.create :name => "David", :surname => "Smith", :age => "32", :premium => "1", :notes => "One of our top customers!"
        end
    
        def self.down 
          # Delete the "Customers" table
            drop_table :customers
          end
        end

  id: "3"
  summary: what a migration file looks like
sections_004: 
  permalink: rake-tasks
  content_id: "1"
  title: Rake tasks
  body: |-
    ## Rake tasks
    
    (Tab.1 Rake Tasks)
    
    Generate migration              
    -----------------------------------------
      `ruby script/generate migration your_chosen_migration_name`
    
    run all unapplied migrations    
    -----------------------------------------
      `rake db:migrate`
    
    migrate database to specific version    
    -----------------------------------------
     `rake db:migrate VERSION=18`
    
    use your migrations to recreate the tables in the testing or production databases
    ---------------------------------------------------------------------------------
      `rake db:migrate RAILS_ENV=production`
    
    Create a `db/schema.rb` file that can be portably used against any database supported by ActiveRecord
    -------------------------
      `rake db:schema:dump`
    
    Load a `schema.rb` file into the database
    -----------------------------------------
      `rake db:schema:load`
    
    Loads a `schema.rb` file into the database and then loads the initial database fixtures.
    -----------------------------------------
      `rake db:bootstrap`
  id: "4"
  summary: a list of built-in migration-related Rake tasks
sections_005: 
  permalink: directory-structure
  content_id: "1"
  title: Directory Structure
  body: |-
    ## Directory structure
    
    + rails_root
        + db
            + schema.rb
            + migrate
                + 001_create_customers
                + 002_add_photo
                + 003_alter_surname
  id: "5"
  summary: where migration files go
sections_006: 
  permalink: model-form-input-field-helpers
  content_id: "4"
  title: Model-based input fields
  body: |-
    <subhead>Input field helpers</subhead>
    <p>All of these helpers take an <c>{html_options}</c> hash which will be converted to HTML attributes. E.g. passing <c>:class =&gt; "bold"</c> will add a <c>class="bold"</c> attribute to the HTML tag.</p>
    
    <minihead>text_field</minihead>
    <rh>text_field(:object_name, :method, {html_options})</rh>
    <sample_code aid:trows="2" aid:tcols="2">
    	<Cell>Code:</Cell><Cell><rh>&lt;%= text_field(:post, :title, :size =&gt; 20, :class =&gt; "blue") %&gt;</rh></Cell>
    	<Cell>Output:</Cell><Cell><rh>&lt;input type="text" id="post_title" name="post[title]" size="20" value="#{@post.title}" class="blue" /&gt;</rh></Cell>
    </sample_code>
    
    <minihead>text_area</minihead>
    <r>text_area(:object_name, :method, {html_options})</r>
    <sample_code aid:trows="2" aid:tcols="2">
    	<Cell>Code:</Cell><Cell><rh>&lt;%= text_area(:post, :comment, :size => "20x10", :class => "area") %&gt;</rh></Cell>
    	<Cell>Output:</Cell><Cell><rh>&lt;textarea cols="20" rows="10" id="post_comment" name="post[comment]" class="area"&gt;#{@post.comment}&lt;/textarea&gt;</rh></Cell>
    </sample_code>
    
    <minihead>file_field</minihead>
    <p>Returns a file upload tag. Make sure that your form is using multipart =&gt; true</p>
    <r>file_field(:object_name, :method, {html_options})</r>
    <sample_code aid:trows="2" aid:tcols="2">
    	<Cell>Code:</Cell><Cell><rh>&lt;%= file_field(:post, :attachment, :class =&gt; "file_input") %&gt;</rh></Cell>
    	<Cell>Output:</Cell><Cell><rh>&lt;input type="file" id="post_attachment" name="post[attachment]" class="file_input"&gt;</rh></Cell>
    </sample_code>
    
    
    <minihead>radio_button</minihead>
    
    <p>Returns an <c>&lt;input type="radio"&gt;</c> HTML tag. If the value returned by <c>:method</c> is the same as <c>tag_value,</c> then the radio button will be selected.</p>
    
    <r> radio_button(:object_name, :method, "tag_value", {html_options})</r>
    <sample_code aid:trows="2" aid:tcols="2">
    	<Cell>Code:</Cell><Cell><rh>&lt;%= radio_button(:post, :category, "ruby") %&gt;
    &lt;%= radio_button(:post, :category, "python") %&gt;</rh></Cell>
    	<Cell>Output:</Cell><Cell><rh>&lt;input type="radio" id="post_category" name="post[category]" value="ruby"&gt;
    &lt;input type="radio" id="post_category" name="post[category]" value="python"&gt;</rh></Cell>
    </sample_code>
    
    
    <minihead>check_box</minihead>
    <p>Returns an <c>&lt;input type="checkbox"&gt;</c> HTML tag. If the value returned by <c>:method</c> is above zero, then the checkbox will be checked. <c>checked_value</c> defaults to <c>1</c> while <c>unchecked_value</c> defaults to <c>0</c>.  Because HTML standards say that unchecked checkboxes don't post anything, a hidden field with the same name as the checkbox is automatically created to contain the <c>unchecked_value</c> as a workaround. </p>
    
    <r>check_box(:object_name, :method, {html_options}, "checked_value", "unchecked_value")</r>
    <sample_code aid:trows="2" aid:tcols="2">
    	<Cell>Code:</Cell><Cell><rh>&lt;%= checkbox(:post, :validated, {}, "yes", "no") %&gt;
    &lt;%= radio_button(:post, :category, "python") %&gt;</rh></Cell>
    	<Cell>Output:</Cell><Cell><rh>&lt;input type="checkbox" id="post_validated" name="post[validated]" value="yes" /&gt;
    &lt;input type="hidden" name="post[validated]" value="no"&gt;</rh></Cell>
    </sample_code>
    
    
    <minihead>password_field</minihead>
    
    <r>password_field(:object_name, :method, {html_options})</r>
    <sample_code aid:trows="2" aid:tcols="2">
    	<Cell>Code:</Cell><Cell><rh>&lt;%= password_field(:login, :pass, :size => 20, :class =&gt; "password_input") %&gt;</rh></Cell>
    	<Cell>Output:</Cell><Cell><rh>&lt;input type="password" id="login_pass" name="login[pass]" value="#{@login.pass}" size="20" class="password_input"&gt;</rh></Cell>
    </sample_code>
    
    
    
    <minihead>hidden_field</minihead>
    
    <r>hidden_field(:object_name, :method, {html_options})</r>
    <sample_code aid:trows="2" aid:tcols="2">
    	<Cell>Code:</Cell><Cell><rh>&lt;%= hidden_field(:customer, :barcode) %&gt;</rh></Cell>
    	<Cell>Output:</Cell><Cell><rh>&lt;input type="hidden" id="customer_barcode" name="customer[barcode]" value="#{@customer.barcode}" /&gt;</rh></Cell>
    </sample_code>
  id: "6"
  summary: create HTML <code>&lt;input&gt;</code> fields that work with your models
sections_007: 
  permalink: form-parameters
  content_id: "4"
  title: Params
  body: |-
    <subhead>params[] </subhead>
    
    <p>When a form is submitted to a Rails application, it parses the raw data and constructs a special hash called <c>params</c> for us to access that data. Simple key/value pairs in the form are converted into key/value pairs in the params hash. However, if a form field contains square brackets <c>[]</c>, Rails will create nested hashes as follows: </p>
    
    <Table aid:trows="5" aid:tcols="2">
    	<Cell><h3>Form input</h3></Cell>
    	<Cell><h3>params hash</h3></Cell>
    	<Cell><r>id=3245</r></Cell>
    	<Cell><r>{:id =&gt; &quot;3245&quot;}</r></Cell>
    	<Cell><r>customer[name]=Miranda</r></Cell>
    	<Cell><r>{:customer =&gt; {:name =&gt; &quot;Miranda}}</r></Cell>
    	<Cell><r>customer[dob][year]=1979</r></Cell>
    	<Cell><r>{:customer =&gt; {:dob =&gt; {:year =&gt; &quot;1979&quot;}}}</r></Cell>
    	<Cell><r>customer[dob][month]=Jan</r></Cell>
    	<Cell><r>{:customer =&gt; {:dob =&gt; {:month =&gt; &quot;Jan&quot;}}}</r></Cell>
    </Table> 
    
    <p>So to find the value of <c>id</c> we would use <c>params[:id]</c>. To find the value of the <c>customer[name]</c> we would use <c>params[:customer][:name]</c>.</p>
  id: "7"
  summary: How form parameters get passed into the <code>params[]</code> hash
